{"version":3,"sources":["parenchym/fs/uploader-controller.js"],"names":[],"mappings":"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","file":"parenchym/fs/uploader-controller.js","sourcesContent":["angular.module('pym.fs').controller('pymFsUploaderController',\n        ['$scope', '$window', '$log', 'T', 'pymService', 'pymFsService', 'pymFsUploaderService', 'FILE_STATES', '$q',\nfunction ($scope,   $window,   $log,   T,   pym,          pymFsService,   pymFsUploaderService,   FILE_STATES,   $q) {\n\n    \"use strict\";\n\n    var ctrl = this;\n    ctrl.FILE_STATES = FILE_STATES;\n\n    // Storage for $uploader service\n    ctrl.files = [];\n    ctrl.rejectedFiles = [];\n    ctrl.isDropAvailable = null;\n\n    // Enqueued files to validate and upload\n    ctrl.queue = {};\n    // Several counters, updated by countActiveUploads watcher\n    // Active means either validating or uploading\n    ctrl.activeUploads = 0;\n    // Validation errors + upload errors\n    ctrl.errors = 0;\n    // Transferring data\n    ctrl.uploading = 0;\n    // total progress\n    ctrl.totalProgress = 0;\n\n    ctrl.windowMaximized = true;\n    ctrl.windowIsOpen = false;\n\n    ctrl.countActiveUploads = function () {\n        var n = 0, e = 0, u = 0, p = 0, len = 0;\n        angular.forEach(ctrl.queue, function (f) {\n            if (f.isActive) { ++n; }\n            if (f.hasError) { ++e; }\n            if (f.isUploading) { ++u; }\n            p += f.progress;\n            ++len;\n        });\n        ctrl.activeUploads = n;\n        ctrl.errors = e;\n        ctrl.uploading = u;\n        if (len !== 0) {\n            ctrl.totalProgress = parseInt(p / len);\n        }\n        return ctrl.activeUploads;\n    };\n\n    $scope.$watch(ctrl.countActiveUploads, function (newValue, oldValue) {\n        if (newValue === 0 && newValue !== oldValue && pymFsService.onUploadFinished) {\n            pymFsService.onUploadFinished();\n        }\n    });\n\n    ctrl.minimaxWindow = function () {\n        ctrl.windowMaximized = !ctrl.windowMaximized;\n    };\n\n    /**\n     * Cancels all active uploads.\n     *\n     * Lets user confirm. Response is triggered by an event, iow, it arrives\n     * asynchronously. (We use our own dialog, not $window.confirm.)\n     *\n     * We may get called from another function (closeWindow), so return a promise\n     * to signal what the user selected.\n     *\n     * If there are no active downloads, we do not let the user confirm. Still\n     * return a promise, a resolved one, so the caller is cleared to do his\n     * thing.\n     *\n     * @returns {promise}\n     */\n    ctrl.cancelAll = function () {\n        if (ctrl.activeUploads) {\n            return pym.growler.confirm(T.confirm_cancel_all_uploads)\n            .then(\n                function () {\n                    angular.forEach(ctrl.queue, function (f) {\n                        f.abort();\n                    });\n                }\n            );\n        }\n        else {\n            return $q.defer().resolve();\n        }\n    };\n\n    ctrl.closeWindow = function () {\n\n        function doIt () {\n            ctrl.clearQueue();\n            ctrl.windowIsOpen = false;\n        }\n\n        if (ctrl.activeUploads) {\n            ctrl.cancelAll().then(doIt);\n        }\n        else {\n            doIt();\n        }\n    };\n\n    ctrl.fileDropped = function ($files, $event, $rejectedFiles) {\n        $log.log('dropped', $files, this.files, $event);\n        if ($files && $files.length > 0) {\n            this.enqueue($files);\n        }\n    };\n\n    ctrl.fileSelected = function ($files, $event) {\n        $log.log('selected', $files, this.files, $event);\n        if ($files && $files.length > 0) {\n            this.enqueue($files);\n        }\n    };\n\n    ctrl.validate = function ($file) {\n        $log.log('Validating file', $file);\n        return $file.type !== 'audio/x-ape';\n    };\n\n    ctrl.clearQueue = function () {\n        var prop;\n        for (prop in ctrl.queue) {\n            if (ctrl.queue.hasOwnProperty(prop)) {\n                delete ctrl.queue[prop];\n            }\n        }\n    };\n\n    ctrl.enqueue = function (files) {\n        var self = this,\n            i, imax, f,\n            myQueue = {};\n        if (! (files && files.length > 0)) { return; }\n        ctrl.windowIsOpen = true;\n        for (i=0, imax=files.length; i<imax; i++) {\n            f = new pymFsUploaderService.createPymFile(files[i]);\n            if (self.queue[files[i].name]) {\n                f.setState(FILE_STATES.VALIDATION_ERROR);\n                f.validationMessage = 'File with this name already in queue';\n                f.key = f.file.name + new Date();\n            }\n            else {\n                f.setState(FILE_STATES.VALIDATING);\n                self.validateHere(f);\n                f.key = f.file.name;\n            }\n            myQueue[f.key] = f;\n            self.queue[f.key] = f;\n        }\n        pymFsUploaderService.validateFiles(pymFsService.getPathStr(), myQueue);\n    };\n\n    ctrl.validateHere = function (f) {\n        // TODO Check quota. If violation, set state and message, if ok, keep state as VALIDATING\n    };\n\n    ctrl.cbProgress = function (evt) {\n        var n = parseInt(100.0 * evt.loaded / evt.total);\n        //$log.log('progress: ' + n + '% file :'+ evt.config.file.name);\n        //$log.log('progress-evt: ', evt);\n        //$log.log('progress-this: ', this);\n        this.progress = n;\n    };\n\n    //ctrl.cbSuccess = function (data, status, headers, config) {\n    //    // file is uploaded successfully\n    //    $log.log('file ' + config.file.name + 'is uploaded successfully. Response: ' + data);\n    //    //this.setState(FILE_STATES.UPLOAD_OK);\n    //};\n\n    ctrl.startUpload = function () {\n        var self = this,\n            p,\n            fProgress; //, fSuccess;\n        angular.forEach(self.queue, function(f) {\n            if (f.state === FILE_STATES.CAN_UPLOAD) {\n                $log.log('starting upload of', f.file.name, f);\n                // Bind the callbacks to the individual PymFile, so that\n                // their 'this' points to the PymFile instance.\n                fProgress = angular.bind(f, self.cbProgress);\n                //fSuccess = angular.bind(f, self.cbSuccess);\n                p = pymFsUploaderService.upload(pymFsService.getPathStr(), f)\n                    .progress(fProgress);\n                    //.success(fSuccess);\n            }\n        });\n    };\n\n    ctrl.cancel = function (file) {\n        file.abort();\n    };\n\n    /**\n     * Checks given mime-type against pattern from ``allow`` and ``deny``\n     * and returns true if mime-type is allowed, false otherwise.\n     */\n    ctrl.checkType = function (ty) {\n        var self = this,\n            i, imax, pat, good;\n        if (! ty) {ty = 'application/octet-stream';}\n        ty = ty.split('/');\n        $log.log(ty);\n        // Is given mime type allowed?\n        good = false;\n        for (i=0, imax=self.allow.length; i<imax; i++) {\n            pat = self.allow[i];\n            if (pat.search(/\\*/) > -1 && pat.search(/\\.\\*/) === -1) {\n                pat = pat.replace(\n                    /\\*/g,\n                    '.*'\n                );\n            }\n            pat = pat.split('/');\n            if (ty[0].search(pat[0]) > -1 && ty[1].search(pat[1]) > -1) {\n                good = true;\n                break;\n            }\n        }\n        if (! good) {return false;}\n        // Is given mime type denied?\n        for (i=0, imax=self.deny.length; i<imax; i++) {\n            pat = self.deny[i];\n            if (pat.search(/\\*/) > -1 && pat.search(/\\.\\*/) === -1) {\n                pat = pat.replace(\n                    /\\*/g,\n                    '.*'\n                );\n            }\n            pat = pat.split('/');\n            if (ty[0].search(pat[0]) > -1 || ty[1].search(pat[1]) > -1) {\n                good = false;\n                break;\n            }\n        }\n        return good;\n    };\n\n    ctrl.checkSize = function (sz) {\n        return (sz >= this.minSize && sz <= this.maxSize);\n    };\n\n    //function init() {\n    //    var i, f;\n    //    for (i=0; i<10; i++) {\n    //        f = new pymFsUploaderService.createPymFile({\n    //            name: 'dfdsffs sdfsgdfg fgsfgfdg sdfgfdg sdfgs dfg sdfg dfgsdfdg sdfgdfgs dfg d dsdgfsfdsg',\n    //            size: 6523856653,\n    //            type: 'stuff/sample'\n    //                        });\n    //        f.setState(i % 2 === 0 ? FILE_STATES.UPLOAD_ERROR : FILE_STATES.CAN_UPLOAD);\n    //        f.validationMessage = 'blah bÃ¶lddf erwe';\n    //        ctrl.queue[i] = f;\n    //    }\n    //    ctrl.windowIsOpen = true;\n    //}\n    //\n    ///*\n    //* Run immediately\n    //*/\n    //init();\n\n}]);\n"],"sourceRoot":"/source/"}